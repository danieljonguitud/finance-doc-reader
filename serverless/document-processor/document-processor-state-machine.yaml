QueryLanguage: JSONata
StartAt: Set Input Variables
States:
  Set Input Variables:
    Type: Pass
    Next: Request Mistral OCR for Markdown
    Assign:
      bucket: '{% $states.input.bucket %}'
      key: '{% $states.input.key %}'
  Request Mistral OCR for Markdown:
    Type: Task
    Resource: arn:aws:states:::lambda:invoke
    Output: '{% $states.result.Payload %}'
    Arguments:
      FunctionName: ${RequestOcrFunctionArn}
      Payload:
        bucket: '{% $bucket %}'
        key: '{% $key %}'
    Retry:
      - ErrorEquals:
          - States.ALL
        IntervalSeconds: 1
        MaxAttempts: 3
        BackoffRate: 2
        JitterStrategy: FULL
    Next: Store MD File
    Assign:
      extractedText: '{% $states.result.Payload.extractedText %}'
  Store MD File:
    Type: Task
    Arguments:
      Body: '{% $extractedText %}'
      Bucket: '{% $bucket %}'
      Key: '{% $replace($key, ''.pdf'', ''.md'') %}'
    Resource: arn:aws:states:::aws-sdk:s3:putObject
    Next: Bedrock InvokeModel
  Bedrock InvokeModel:
    Type: Task
    Resource: arn:aws:states:::bedrock:invokeModel
    Arguments:
      ModelId: >-
        arn:aws:bedrock:us-west-2::foundation-model/${FoundationalModelId}
      Body:
        anthropic_version: bedrock-2023-05-31
        max_tokens: 4096
        temperature: 0
        messages:
          - role: user
            content:
              - type: text
                text: >-
                  {% 'You are a financial data extraction assistant. Your task
                  is to analyze bank statements provided as extracted text from
                  a PDF document and extract all transactions into a structured
                  JSON format.


                  ## Instructions

                  1. Carefully read the provided bank statement text that was
                  extracted from a PDF

                  2. Extract all transactions with their details

                  3. Return the data in the specified JSON format

                  4. If any information is not available in the statement, use
                  "N/A" as the value

                  5. Ensure all monetary values are returned as floats with 2
                  decimal points (not strings)

                  6. Look for the Bank account details, this includes, account name
                  (not customer name), account balance, institution and type from
                  the next types: checking, credit_card

                  7. Dates should be in ISO 8601 format (YYYY-MM-DD)

                  8. You must only use the categories from the list of available
                  categories. If there is no category suitable for a given
                  transaction, you must use "Otros"

                  9. The output should be in JSON format only and nothing else

                  ## Available Categories:

                  - Restaurantes - Despensa - Ropa - Cuidado Personal -
                  Medicamentos - Gasolina - Impuestos - Comisiones Bancarias -
                  Intereses Bancarios - Financiamiento Automotriz - Hipoteca -
                  Tranferencia Bancaria - Servicios Digitales - Sueldos y
                  Salarios - Pago de Tarjeta de Credito - Otros

                  ## Expected JSON Output Format

                  { 
                    "accountInfo": {
                      "institutionName": <string or N/A>,
                      "accountNumber": <string or N/A>,
                      "accountName": <string or N/A>,
                      "accountType": <checking or credit_card>,
                      "accountBalance": <float/currency>,
                      "statementPeriod": {
                        "startDate": <YYYY-MM-DD or N/A>,
                        "endDate": <YYYY-MM-DD or N/A>"
                      }
                    },
                    "transactions": [
                      {
                        "date": <YYYY-MM-DD>,
                        "description": <string or N/A>,
                        "amount": <float/currency>,
                        "type": <expense or income>,
                        "category": <string or N/A>
                      }
                    ]
                  }

                  ## Additional Guidelines:

                  - Handle various date formats and convert them to ISO 8601

                  - Remove currency symbols and convert to floats with 2 decimal
                  points values

                  - If the bank statement has additional columns not in the
                  expected format, extract what is available

                  - If transactions are not in a table format, extract them from
                  the text

                  - Validate that the calculated totals match the statement if
                  possible

                  - Some bank staments transactions start from: "Detalle de
                  Movimientos", "Detalle de Operaciones", "Movimientos",
                  "Transacciones Bancarias"

                  - Sometimes the transactions table divided with text due to a
                  page separation. Keep this in mind to not lose transactions

                  ## Bank Statement Text to Analyze: 

                  ' & $extractedText %}
    Next: Convert Output to JSON
    Retry:
      - ErrorEquals:
          - States.AWS.Bedrock.ThrottlingException
          - States.AWS.Bedrock.ServiceQuotaExceededException
        IntervalSeconds: 5
        MaxAttempts: 3
        BackoffRate: 2
  Convert Output to JSON:
    Type: Pass
    Assign:
      processedContent: '{% $parse($states.input.Body.content[0].text) %}'
      processingMetadata:
        bucket: '{% $bucket %}'
        key: '{% $key %}'
        modelId: anthropic.claude-3-5-haiku-20241022-v1:0
        timestamp: '{% $now() %}'
    Next: Create or Get Account
  Create or Get Account:
    Type: Task
    Resource: arn:aws:states:::lambda:invoke
    Arguments:
      FunctionName: ${DataLambdaArn}
      Payload:
        operation: create
        sql: >-
          INSERT INTO accounts (user_id, account_name, account_type, institution, 
          account_number_hash, display_digits, is_liability, account_balance) 
          VALUES (:userId::uuid, :accountName, :accountType, :institution, 
          encode(sha256(:accountNumber::bytea), 'hex'), 
          '****' || right(:accountNumber, 4), :isLibility, :accountBalance) 
          ON CONFLICT (user_id, account_number_hash) 
          DO UPDATE SET updated_at = CURRENT_TIMESTAMP, account_balance = :accountBalance
          RETURNING id
        parameters:
          - name: userId
            value:
              stringValue: '{% $split($key, "/")[0] %}'
          - name: accountName
            value:
              stringValue: '{% $processedContent.accountInfo.accountName %}'
          - name: accountType
            value:
              stringValue: 'checking'
          - name: institution
            value:
              stringValue: '{% $processedContent.accountInfo.institutionName %}'
          - name: accountNumber
            value:
              stringValue: '{% $processedContent.accountInfo.accountNumber %}'
          - name: isLiability
            value:
              booleanValue: "{% $processedContent.accountInfo.accountType = 'credit_card' ? true : false %}"
          - name: accountBalance
            value:
              doubleValue: '{% $processedContent.accountInfo.accountBalance %}'
    Retry:
      - ErrorEquals:
          - States.ALL
        IntervalSeconds: 2
        MaxAttempts: 3
        BackoffRate: 2
    Next: Prepare Database Context
    Assign:
      accountId: '{% $states.result.Payload.records[0].id %}'
  Prepare Database Context:
    Type: Pass
    Assign:
      userId: '{% $split($key, "/")[0] %}'
      clusterArn: ${AuroraClusterArn}
      secretArn: ${DatabaseSecretArn}
      database: ${DatabaseName}
    Next: Prepare Transaction Parameter Sets
  Prepare Transaction Parameter Sets:
    Type: Pass
    Assign:
      parameterSets: |-
        {% 
          $map($processedContent.transactions, function($transaction) {
            [
              {"name": "userId", "value": {"stringValue": $userId}},
              {"name": "accountId", "value": {"longValue": $accountId}},
              {"name": "transactionDate", "value": {"stringValue": $transaction.date}},
              {"name": "description", "value": {"stringValue": $transaction.description}},
              {"name": "amount", "value": {"doubleValue": $transaction.amount}},
              {"name": "transactionType", "value": {"stringValue": $transaction.type}},
              {"name": "category", "value": {"stringValue": $transaction.category}}
            ]
          })
        %}
    Next: Insert All Transactionss
  Insert All Transactionss:
    Type: Task
    Resource: arn:aws:states:::lambda:invoke
    Output: '{% $states.result.Payload %}'
    Arguments:
      FunctionName: ${DataLambdaArn}
      Payload:
        operation: create
        sql: >-
          INSERT INTO transactions (user_id, account_id, transaction_date, description,
          amount, transaction_type, category) VALUES (:userId::uuid, :accountId,
          :transactionDate::date, :description, :amount, :transactionType,
          :category)
        parameters: '{% $parameterSets %}'
    Retry:
      - ErrorEquals:
          - States.ALL
        IntervalSeconds: 1
        MaxAttempts: 3
        BackoffRate: 2
        JitterStrategy: FULL
    Assign:
      insertResult: '{% $states.result %}'
    Next: Finalize Processing
  Finalize Processing:
    Type: Pass
    Assign:
      finalResult:
        processingMetadata: '{% $processingMetadata %}'
        accountInfo: '{% $processedContent.accountInfo %}'
        databaseResult:
          userId: '{% $userId %}'
          accountId: '{% $accountId %}'
          transactionsInserted: '{% $count($processedContent.transactions) %}'
          insertResult: '{% $insertResult %}'
    End: true
